---
title: 994.Rotten orange.md
date: 2024.05.14 0:00
tags:
  - Python
  - BFS
  - Bilateral queue
abbrlink: 56e64fdd
---

# topicï¼š

"""
<p>Given&nbsp;<code>m x n</code>&nbsp;grid
 <meta charset="UTF-8" />&nbsp;<code>grid</code>&nbsp;middleï¼ŒEach cell can have one of the following three valuesï¼š</p>

<ul> 
 <li>value&nbsp;<code>0</code>&nbsp;Represents the empty unitï¼›</li> 
 <li>value&nbsp;<code>1</code>&nbsp;Represents fresh orangesï¼›</li> 
 <li>value&nbsp;<code>2</code>&nbsp;ä»£è¡¨Rotten orangeã€‚</li> 
</ul>

<p>every minuteï¼ŒRotten orange&nbsp;<strong>around&nbsp;4 Adjacent in this direction</strong> Fresh oranges will rotã€‚</p>

<p>return <em>ç›´åˆ°å•å…ƒæ ¼middleæ²¡æœ‰æ–°é²œæ©˜å­ä¸ºæ­¢æ‰€å¿…é¡»ç»è¿‡çš„æœ€å°åˆ†é’Ÿæ•°ã€‚If it is impossibleï¼Œreturn&nbsp;<code>-1</code></em>&nbsp;ã€‚</p>

<p>&nbsp;</p>

<p><strong>Exemplary example 1ï¼š</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" style="height: 137px; width: 650px;" /></strong></p>

<pre>
<strong>enterï¼š</strong>grid = [[2,1,1],[1,1,0],[0,1,1]]
<strong>Outputï¼š</strong>4
</pre>

<p><strong>Exemplary example 2ï¼š</strong></p>

<pre>
<strong>enterï¼š</strong>grid = [[2,1,1],[0,1,1],[1,0,1]]
<strong>Outputï¼š</strong>-1
<strong>explainï¼š</strong>Orange in the lower left cornerï¼ˆFirst 2 OKï¼Œ First 0 Listï¼‰Never rotï¼ŒBecause rotten will only happen in 4 In the directionã€‚
</pre>

<p><strong>Exemplary example 3ï¼š</strong></p>

<pre>
<strong>enterï¼š</strong>grid = [[0,2]]
<strong>Outputï¼š</strong>0
<strong>explainï¼š</strong>because 0 There is no fresh orange in minutesï¼ŒSo the answer is 0 ã€‚
</pre>

<p>&nbsp;</p>

<p><strong>hintï¼š</strong></p>

<ul> 
 <li><code>m == grid.length</code></li> 
 <li><code>n == grid[i].length</code></li> 
 <li><code>1 &lt;= m, n &lt;= 10</code></li> 
 <li><code>grid[i][j]</code> Only for&nbsp;<code>0</code>ã€<code>1</code>&nbsp;or&nbsp;<code>2</code></li> 
</ul>

<div><div>Related Topics</div><div><li>Priority search</li><li>Array</li><li>matrix</li></div></div><br><div><li>ğŸ‘ 872</li><li>ğŸ‘ 0</li></div>
"""

# Thoughtï¼š

è¿™ä¸ªé—®é¢˜å¯ä»¥ç”¨Priority searchï¼ˆBFSï¼‰To solveã€‚We need to track the spread of rotten orangesï¼ŒRecord timeï¼ŒAnd check if there is a fresh orange that cannot be rottenã€‚The initial idea of â€‹â€‹the original ideaï¼š
```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        bad_orange = []
        # æ‰¾åˆ°æ‰€æœ‰åˆå§‹Rotten orange
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 2:
                    # å­˜å…¥åˆå§‹é˜ŸList
                    bad_orange.append((i, j))
```
Similar to multi -threadedï¼Œæ¯ä¸ªçº¿ç¨‹å­˜å…¥ä¸€ä¸ªåˆå§‹é˜ŸListï¼Œåˆå§‹é˜ŸListé€šè¿‡BFSGradual diffusion

# Codeï¼š

```python
from collections import deque

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        bad_orange = deque()
        fresh_oranges = 0
        rows, cols = len(grid), len(grid[0])
        
        # æ‰¾åˆ°æ‰€æœ‰åˆå§‹Rotten orangeï¼ŒAnd calculate the number of fresh oranges
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 2:
                    bad_orange.append((i, j))
                elif grid[i][j] == 1:
                    fresh_oranges += 1
        
        # æ–¹å‘Arrayï¼šup down left right
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # If there is no fresh orangeï¼Œç›´æ¥return 0
        if fresh_oranges == 0:
            return 0
        
        # BFS
        minutes = 0
        while bad_orange:
            minutes += 1
            for _ in range(len(bad_orange)):
                x, y = bad_orange.popleft()
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1:
                        grid[nx][ny] = 2
                        fresh_oranges -= 1
                        bad_orange.append((nx, ny))
        
        # If there are fresh orangesï¼Œreturn -1
        return minutes - 1 if fresh_oranges == 0 else -1
```

```go
import (
	"sync"
)

func orangesRotting(grid [][]int) int {
	rows, cols := len(grid), len(grid[0])
	badOranges := make([][2]int, 0)
	freshOranges := 0

	// æ‰¾åˆ°æ‰€æœ‰åˆå§‹Rotten orangeï¼ŒAnd calculate the number of fresh oranges
	for r := 0; r < rows; r++ {
		for c := 0; c < cols; c++ {
			if grid[r][c] == 2 {
				badOranges = append(badOranges, [2]int{r, c})
			} else if grid[r][c] == 1 {
				freshOranges += 1
			}
		}
	}

	// If there is no fresh orangeï¼Œç›´æ¥return 0
	if freshOranges == 0 {
		return 0
	}

	directions := [][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}
	minutes := 0

	var wg sync.WaitGroup

	// BFS
	for len(badOranges) > 0 {
		minutes++
		nextBadOranges := make([][2]int, 0)
		for _, orange := range badOranges {
			x, y := orange[0], orange[1]
			wg.Add(1)
			go func(x, y int) {
				defer wg.Done()
				for _, d := range directions {
					nx, ny := x+d[0], y+d[1]
					if nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1 {
						grid[nx][ny] = 2
						nextBadOranges = append(nextBadOranges, [2]int{nx, ny})
						freshOranges--
					}
				}
			}(x, y)
		}
		wg.Wait()
		badOranges = nextBadOranges
	}

	// If there are fresh orangesï¼Œreturn -1
	if freshOranges > 0 {
		return -1
	}
	return minutes - 1
}
```